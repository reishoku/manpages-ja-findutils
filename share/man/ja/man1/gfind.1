.\" -*- nroff -*-
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.\"    This file documents the GNU utilities for finding files that match
.\" certain criteria and performing various operations on them.
.\" 
.\"    Copyright (C) 1994 Free Software Foundation, Inc.
.\" 
.\"    Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\" 
.\"    Permission is granted to copy and distribute modified versions of
.\" this manual under the conditions for verbatim copying, provided that
.\" the entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\" 
.\"    Permission is granted to copy and distribute translations of this
.\" manual into another language, under the above conditions for modified
.\" versions, except that this permission notice may be stated in a
.\" translation approved by the Foundation.
.\"
.\" Japanese Version Copyright (c) 1997 NAKANO Takeo
.\"   and 2010 Chonan Yoichi 
.\"         all rights reserved.
.\" Translated Thu May 11 1997 by NAKANO Takeo <nakano@apm.seikei.ac.jp>
.\" Modified Fri 14 Aug 1998 by NAKANO Takeo -- bug fixes.
.\" Updated and modified (findutils-4.4.2) Mon Dec 20 21:17:50 JST 2010
.\"         by Chonan Yoichi <cyoichi@maple.ocn.ne.jp>
.\" Modified Sun Jan 30 11:44:29 JST 2011 by Chonan Yoichi
.\" Updated and modified (findutils-4.6.0) Sat Mar  3 11:18:22 JST 2018
.\"         by Chonan Yoichi
.\"
.\" WORD    expression   式
.\" WORD    predicate    述語 (式を構成するオプション、検査、アクションを
.\"                            一まとめにした言い方)
.\" WORD    test(s)      検査 (4.4.2 までは判別式と訳していたが、変更した)
.\" WORD    directive    書式指定子
.\" WORD    access time           アクセス日時
.\" WORD    status change time    ステータス変更日時
.\" WORD    modification time     内容更新日時
.\" WORD    birth time            (ファイルの)作成日時
.\"
.TH FIND 1   
.SH 名前
find \- ディレクトリ階層をたどって、条件を満たすファイルを検索する
.SH 書式
\fBfind\fP [\-H] [\-L] [\-P] [\-D debugopts] [\-Olevel] [starting\-point...]
[expression]
.SH 説明
このマニュアルページは GNU 版 \fBfind\fP の使用法を説明している。
GNU 版 \fBfind\fP は、指定された探索開始点 (訳注: 探索の始点となるパス。上記書式の
starting\-point...) 以下のディレクトリツリーを一つづつ探索し、与えられた式
(訳注: 上記書式の expression) を、優先規則に従いつつ (「演算子」セクションを参照)、
左から右へ評価することによって検索を行う。 式の結果が確定すると
(たとえば、\fIand\fP 演算で左辺が偽になった場合や、\fIor\fP 演算で左辺が真になった場合など)、
\fBfind\fP は処理の対象を次のファイル名に移す。
探索開始点が指定されていない場合は、`.' が指定されたものと見なされる。
.PP
もし \fBfind\fP を使用しているのが、セキュリティの問題をおろそかにできない環境なら
(たとえば、 \fBfind\fP を使って探索しているディレクトリが、自分以外のユーザにも書き込み可能な場合など)、
findutils 関連文書の 「Security Considerations」の章をお読みになるとよい。
\fBFinding Files\fP という文書で、findutils に同梱されているはずだ
(訳注: \fBinfo "Finding Files"\fP で読むことができる)。
その文書では、他の点についてもこのマニュアルページよりはるかに詳しい説明や考察が行われているので、
この文書以上に情報源としてお役に立つことだろう。
.SH オプション
\fB\-H\fP, \fB\-L\fP, \fB\-P\fP というオプションは、シンボリックリンクをどう処理するかを決める。
こうしたオプションに続くコマンドライン引き数は、探索対象となるファイル名やディレクトリ名と見なされる。
ただし、それは、`\-' で始まる引き数や、`(' とか `!' という引き数が、続いて現れるまでだ。
そうした引き数、及びそれに続くいかなる引き数も、何を捜すべきかを記述した式であると解釈される。
探索開始点のパスが一つも指定されていない場合は、カレントディレクトリ以下が探索の対象になる。
また、式が一つも指定されていない場合は、\fB\-print\fP が式として使用される
(もっとも、いかなる場合でも、\fB\-print\fP の代わりに \fB\-print0\fP
の使用を考えた方が多分よいだろうが)。
.PP
このマニュアルページで説明する「オプション」には、式の一部として使われるものもある。
そうしたオプションは、\fBfind\fP の動作を制御するものであり、指定する位置は、探索開始点の最後のパス名のすぐ後になる。
それに対して、\fB\-H\fP, \fB\-L\fP, \fB\-P\fP, \fB\-D\fP, \fB\-O\fP
という五つの「本来」のオプションは、指定するなら、最初のパス名の前で指定しなければならない。
なお、ダッシュを二個重ねた \fB\-\-\fP を使用して、後に続く引き数はオプションではないと明示することも可能だ
(それでも、探索開始点となるパス名のリストでワイルドカードを使用するならば、
始点のすべてが `./' か `/' で始まるようにしておいた方が、たいてい無難である)。
.IP \-P
シンボリックリンクをまったくたどらない。これがデフォルトの動作である。\fBfind\fP
がファイルの情報を調べたり表示したりする際に、そのファイルがシンボリックリンクだったら、
そのシンボリックリンクそのもののプロパティから取得した情報が使用されることになる。

.IP \-L
シンボリックリンクをたどる。\fBfind\fP がファイルの情報を調べたり表示したりする際に、
リンク先のファイルのプロパティから取得した情報が使用されることになり、
リンクそのものの情報は利用されない (ただし、シンボリックリンクがリンク切れしていたり、
\fBfind\fP がリンク先のファイルを調べることができなかった場合は除く)。
このオプションを使用すると、自動的に \fB\-noleaf\fP が指定される。
後で \fB\-P\fP オプションを指定し直しても、\fB\-noleaf\fP は依然として有効なままである。
\fB\-L\fP が有効になっているとき、\fBfind\fP が探索中にサブディレクトリを指すシンボリックリンクに出会うと、
そのシンボリックリンクが参照しているサブディレクトリが探索される。
.IP
\fB\-L\fP オプションが有効だと、述語 \fB\-type\fP は
(訳注: 「述語 (predicate)」とは、式を構成する基本要素、すなわち、オプション、検査、
アクションのこと)、シンボリックリンクそのものに対してではなく、
常にシンボリックリンクが指しているファイルのタイプに対してマッチを行うようになる
(シンボリックリンクがリンク切れしている場合を除く)。
\fBfind\fP の実行中にシンボリックリンクがリンク切れになるようなアクションを行うと
(たとえば、\fB\-delete\fP を使うと)、動作がわけのわからないものになるかもしれない。
\fB\-L\fP を使用すると、述語 \fB\-lname\fP や \fB\-ilname\fP は常に偽を返す。

.IP \-H
コマンドライン上で指定された引き数を処理するとき以外、シンボリックリンクをたどらない。
すなわち、原則として、 \fBfind\fP がファイルの情報を調べたり表示したりする際に、
シンボリックリンクそのもののプロパティから取得した情報が使用されることになる。
ただし、この動作には例外が一つあり、それは、コマンドラインで指定されたファイルがシンボリックリンクであり、そのリンクが解決できる場合だ。
その場合は、リンク先が何であれ、そこから取得した情報が使用され
(つまり、リンクがたどられる)、シンボリックリンク自体の情報は、リンク先のファイルを調べることができなかったときの、控えの情報として使用される。
なお、\fB\-H\fP が有効なとき、コマンドラインで指定されたパスの中に (訳注: つまり探索開始点の中に)
ディレクトリへのシンボリックリンクがあった場合も、そのディレクトリの中身が調べられることになる
(もっとも、\-maxdepth 0 を指定すれば、 当然ながら、この動作は抑制されることになるだろうが)。
.P
一つ以上の \fB\-H\fP, \fB\-L\fP, \fB\-P\fP を指定した場合は、後のものが前のものを上書きする。
従って、コマンドラインで最後に指定されたものが、効果を持つわけだ。
\fB\-P\fP はデフォルトなので、\fB\-H\fP や \fB\-L\fP を指定しないかぎり、\fB\-P\fP
オプションが有効になっていると考えるべきである。

GNU \fBfind\fP は実際の探索に取りかかる前にコマンドラインの処理を行うが、
その際 stat システムコールを使ってファイルの情報を調べることがよくある。
上述のオプションは、そのとき引き数がどう処理されるかにも影響を与える。
具体的に説明しよう。いくつかの検査では、コマンドラインで指定したファイルを目下検査の対象になっているファイルと照合する。
いづれの検査でも、コマンドラインで指定したファイルは、情報が調べられた後、そのプロパティのいくつかが保存されることになる。
名前を指定したファイルが実際にはシンボリックリンクであるとき、\fB\-P\fP オプションが有効な場合は
(すなわち、 \fB\-H\fP と \fB\-L\fP のどちらのオプションも指定されていない場合は)、
照合に使用される情報は、シンボリックリンクのプロパティから取得したものである。
それ以外の場合、使用されるのはリンク先のファイルのプロパティから取得した情報だ。
ただし、\fBfind\fP が (たとえば、権限が不十分だとか、リンク先のファイルが存在しないとかの理由で)
リンクをたどれない場合は、リンクそのもののプロパティが使われることになる。
.P
\fB\-H\fP や \fB\-L\fP オプションが有効な場合は、
\fB\-newer\fP の引き数として指定されたのがシンボリックリンクなら、
その参照がたどられて、リンク先のファイルからタイムスタンプが取得されることになる。
同じことが、 \fB\-newerXY\fP, \fB\-anewer\fP, \fB\-cnewer\fP についても言える。

式の一部として使用される \fB\-follow\fP オプションには \fB\-L\fP と同様の効果があるが、
それが現れた位置から有効になるという点が異なる
(すなわち、\fB\-L\fP が使われずに、\fB\-follow\fP が使われた場合、
\fB\-follow\fP より後で指定されたいかなるシンボリックリンクも参照がたどられるが、
その前に指定されたシンボリックリンクは参照がたどられない)。

.IP "\-D debugoptions"
診断用の情報を出力する。\fBfind\fP が期待どおりに動いてくれないとき、
問題の原因追求に役立つことがある。デバッグオプションを複数指定するときは、コンマで区切る。
findutils のバージョンの間で、デバッグオプションの互換性は保証されていない。
有効な全デバッグオプションのリストについては、\fBfind \-D help\fP の出力を見るとよい。
有効なデバッグオプションの中には、以下のものがある。
.RS
.IP help
デバッグ用オプションを説明する。
.IP tree
式の構造 (expression tree) をオリジナルな形と最適化した形で示す。
.IP stat
\fBstat\fP や \fBlstat\fP システムコールを使ってファイルを調べたとき、メッセージを表示する。
\fBfind\fP プログラムは、そうしたシステムコールの回数を最少にしようとする。
.IP opt
式の構造 (expression tree) の最適化に関する診断情報を表示する。\-O オプションを参照。
.IP rates
各述語が何回成功し、何回失敗したかを示す情報を要約して表示する。
.RE
.IP \-Olevel
問い合わせの最適化を有効にする。\fBfind\fP プログラムは、全体的な効果を維持しつつ、検査の順序を並べ替えることによって、実行速度を上げる。
すなわち、付加的な作用のある述語同士については、相互の相対的な順序を変更しないということだ。
各最適化レベルで行われる最適化は、以下のとおりである。
.RS
.IP 0
最適化レベル 1 と同じである。
.IP 1
これはデフォルトの最適化レベルであり、伝統的な動作に当たる。
式を並べ替えるとき、ファイル名にのみ基づいた検査
(たとえば、 \fB\-name\fP や \fB\-regex\fP) が先に実行されるようにする。
.IP 2
検査 \fB\-type\fP や \fB\-xtype\fP の実行は、ファイル名のみに基づいたいかなる検査よりも後になるが、
inode から情報を取得する必要があるどんな検査よりも先になる。
最近の Unix には \fBreaddir()\fP 関数でファイルタイプを取得できるものが多いので、
こうした述語は、stat 関数でファイルの情報を取得するところから始めなければならない述語よりも、評価に時間がかからないのである。
なお、\fB\-fstype\fP \fIFOO\fP という述語を使った場合に、
\fBfind\fP の起動時に既知になっていない (すなわち、`/etc/mtab' に存在しない)
ファイルシステムのタイプ \fIFOO\fP を指定すると、\fB\-fstype\fP \fIFOO\fP は
\fB\-false\fP と同じことになる。
.IP 3
この最適化レベルでは、コストに基づいた問い合わせの最適化を徹底して行う機能が有効になる。
検査の順序が必要なら変更され、コストのかからない (すなわち、速い) 検査が先に行われて、よりコストのかかる検査が後回しにされる。
コストがほぼ同じ場合には、その述語が真を返しそうか、偽を返しそうかによって、評価の順番が変わってくる。
\fBor\fP 演算では、真を返しそうな述語が先に評価され、\fBand\fP 演算では、偽になりそうな述語が先に評価されるのである。
.RE
.IP
コストに基づいた最適化機能は、ある検査が真を返す確率について一定の考えを持っている。
場合によっては、その確率について、問題のテストの特性が考慮されることもある
(たとえば、 \fB\-type f\fP は、 \fB\-type c\fP よりも、真になる可能性が高いと見なされる)。
コストに基づいた最適化機能は、現在のところその効果を評価中である。
もし、それによって \fBfind\fP の性能が実際に向上することがなければ、捨てられることになるだろう。
反対に、信頼性があり、問題を起こしにくく、効果的であることがはっきりした最適化は、
そのうち下位の最適化レベルでも採用されるかもしれない。とは言え、リリース 4.3.x
のシリーズでは、 デフォルトの動作 (すなわち、最適化レベル 1) を変更する予定はない。
なお、findutils のソースに付属するテスト集は、そのテストのすべてを各最適化レベルの
\fBfind\fP で実行して、どの最適化レベルでも結果が同じになることを保証している。
.P
.SH "式 (EXPRESSION)"
コマンドライン上で探索開始点 (starting\-point) のリストの後ろに続く部分は、「式 (\fIexpression\fP)」である。
式は、言わば問い合わせの細目のようなものであり、
どういうファイルがマッチするのかと、そのマッチしたファイルをどう処理するのかを記述している。
式は一連の要素からなっている (訳注: このマニュアルでは、そうした式の要素、
特にオプション、検査、アクションをまとめて「述語 (predicate)」と呼んでいる)。

.IP "検査 (Tests)"
検査は、通常、考慮の対象になっているファイルの何らかのプロパティ
(property、属性、性状) に基づいて、真または偽の値を返す。たとえば、\fB\-empty\fP
という検査は、対象になっているファイルが空の場合にのみ、真になる。

.RS
.IP "[\fB訳注\fP]:" 8
バージョン 4.4.2 までの翻訳では、この \fBTests\fP 
を「判別式」と訳してきたが、今回は素直に「検査」と訳すことにした。同じものである。
.RE
.IP "アクション (Actions)"
アクションには付加的な作用があり (たとえば、標準出力に何かを表示するなど)、
通常、その作用の実行に成功したか失敗したかに基づいて、真または偽を返す。
たとえば、\fB\-print\fP というアクションは、対象になっているファイルの名前を標準出力に表示する。

.IP "グローバルオプション (Global options)"
グローバルオプションは、検査やアクションがコマンドライン中のどこで指定されていても、
その動作に影響を与える。また、グローバルオプションは、常に真を返す。
たとえば、\fB\-depth\fP オプションを指定すると、\fBfind\fP は、ファイルシステムをたどるとき、
深い方から先に (depth\-first order) 処理していくことになる
(訳注: 下記の \fB\-depth\fP の説明を参照)。

.IP "位置オプション (Positional options)"
位置オプションが影響を与えるのは、それより後に続く検査やアクションに対してだけである。
また、位置オプションは常に真を返す。たとえば、\fB\-regextype\fP オプションは、その位置が意味を持ち、
コマンドライン上でそれより後に現れる正規表現に対して、正規表現のどの方言かを指定することになる。

.IP "演算子 (Operators)"
演算子は、式を構成する事項同士を結びつけるものである。
演算子には、\fB\-o\fP (論理 OR を意味する) や \fB\-a\fP (論理 AND を意味する) などがある。
演算子がないところには、\fB\-a\fP があるものと見なされる。

.P
式の中に \fB\-prune\fP や \fB\-print\fP 以外のアクションがまったく存在しない場合は、
式全体の結果が真になったすべてのファイルに対して \fB\-print\fP が実行される。

\fB\-delete\fP というアクションはオプションのようにも働く
(自動的に \fB\-depth\fP を有効にするからである)。

.SS 位置オプション
位置オプションは、常に真を返す。
位置オプションが影響を与えるのは、コマンドライン上でそれより後に現れる検査に対してだけである。

.IP \-daystart
\fB\-amin\fP, \fB\-atime\fP, \fB\-cmin\fP, \fB\-ctime\fP, \fB\-mmin\fP, \fB\-mtime\fP
において、今日 (すなわち 0 日前) の始まりを今現在から 24 時間前ではなく、コマンド実行当日の 0 時にする。
このオプションが影響を及ぼすのは、コマンドラインで自分より後に指定された検査に対してだけである。

.RS
.IP "[\fB訳注\fP]:" 8
.BR \-amin ,
.BR \-cmin ,
.BR \-mmin
のことも考慮するなら、「デフォルトでは時間を計算するときの基点を今現在に置くが、
.B \-daystart
を指定すると、時間計算の基点が今日の 24:00 になる」と考えれば、
わかりやすいかもしれない。
.RE

.IP \-follow
非推奨である。 \fB\-L\fP オプションを代わりに使う方がよい。
シンボリックリンクをたどる。 \fB\-noleaf\fP が自動的に設定される。
\fB\-follow\fP オプションが影響を及ぼすのは、コマンドラインで自分より後に指定された検査に対してだけである。
\fB\-H\fP や \fB\-L\fP オプションが指定されていない場合、\fB\-follow\fP
オプションの位置によって述語 \fB\-newer\fP の動作が変わってくる。
\fB\-newer\fP が \fB\-follow\fP の後に来れば、\fB\-newer\fP
の引き数として指定されたいかなるファイルも、それがシンボリックリンクなら、リンクをたどられることになるわけだ。
同じことが \fB\-newerXY\fP, \fB\-anewer\fP, \fB\-cnewer\fP についても言える。
同様に、述語 \fB\-type\fP も、シンボリックリンクそのものではなく、
必ずシンボリックリンクが参照しているファイルのタイプに対してマッチを行うようになる。
\fB\-follow\fP を使用すると、述語 \fB\-lname\fP と \fB\-ilname\fP は常に偽を返す。

.IP "\-regextype \fItype\fP"
検査 \fB\-regex\fP と \fB\-iregex\fP が理解する正規表現の文法を変更する。
このオプションよりコマンドラインの後方で指定する \fB\-regex\fP などに対して効果がある。
どういう正規表現のタイプが使えるかを知るには、\fB\-regextype\fP \fBhelp\fP を使用すればよい。
様々なタイプの正規表現が、どんなもので、どこが違うかについては、\fBfind\fP の Texinfo
文書に説明がある (「関連項目」を参照)。

.IP "\-warn, \-nowarn"
警告メッセージの表示、非表示を切り替える。
ここで言う警告とは、もっぱらコマンドラインの使用法に関するものであり、\fBfind\fP
がディレクトリを探索中に出会うかもしれない何らかの状況に関するものではない。
デフォルトの動作は、標準入力が tty であれば、\fB\-warn\fP であり、
それ以外の場合は、\fB\-nowarn\fP である。
コマンドラインの使用法に関する警告メッセージが生ずる場合でも、\fBfind\fP
の終了ステータスは影響を受けない。
なお、環境変数 POSIXLY_CORRECT が設定され、しかも \fB\-warn\fP まで指定された場合に、
警告を出すとしても、どの警告を出すかは決まっていない
(訳注: POSIX の規定では、\fBfind\fP は基本的に、エラーメッセージは出しても、警告メッセージは出さないことになっている。
だから、POSIXLY_CORRECT と \fB\-warn\fP の両方を指定するのは、使用法に混乱があるのである。
ちなみに、手元の 4.6.0 では警告は出ない)。

.SS グローバルオプション
グローバルオプションは常に真を返す。
グローバルオプションは、コマンドライン上でそれよりも前にある検査に対しても効果を持つ。
混乱を避けるためには、グローバルオプションは、コマンドライン上で、探索開始点のリストの後ろ、
検査や位置オプションやアクションが現れる前に指定すべきである。
グローバルオプションを他の場所で指定すると、\fBfind\fP
は「混乱の元になりかねない」旨の警告メッセージを出す。

グローバルオプションの位置は、探索開始点のリストより後ろである。だから、\fB\-L\fP
などとは、まったく別種のオプションである。

.IP \-d
\-depth と同じ。FreeBSD, NetBSD, MacOS X, OpenBSD との互換性のためにある。

.IP \-depth
ディレクトリそのものより先に、ディレクトリの中身を処理する。
アクション \fB\-delete\fP を使用すると、\fB\-depth\fP オプションも自動的に設定される。

.IP "\-help, \-\-help"
\fBfind\fP のコマンドラインの使用法をざっと説明して終了する。

.IP \-ignore_readdir_race
通常、\fBfind\fP は stat 関数でファイル情報を取得できなかったとき、
エラーメッセージを出すことになっている。
ところが、このオプションを指定した場合は、
\fBfind\fP がディレクトリからファイル名を読み込んでから、そのファイルに対して
stat 関数を実行しようとするまでの間に、ファイルが消去されても、エラーは表示されない。
この動作は、コマンドラインで名前を指定したファイルやディレクトリに対しても適用される。
このオプションは コマンドラインを読み込む際に有効になるので、
ファイルシステムのある部分をこのオプションを有効にして探索し、
別の部分はこのオプションを無効にして探索するといったことはできない
(そうしたことをやりたかったら、 \fBfind\fP コマンドを二回実行する必要があるだろう。
一回目は、このオプションを付けて、もう一回はこのオプションなしで)。

.IP "\-maxdepth \fIlevels\fP"
探索開始点から最大 \fIlevels\fP 段階下のディレクトリまで探索する (\fIlevels\fP は非負の整数)。
\fB\-maxdepth 0\fP を指定すると、検査やアクションの対象になるのは、探索開始点だけになる。
.IP "\-mindepth \fIlevels\fP"
探索開始点から少なくとも \fIlevels\fP
段階ディレクトリを下降するまで、いかなる検査やアクションも行わない (\fIlevels\fP は非負の整数)。
\fB\-mindepth 1\fP を指定すると、探索開始点を除くすべてのファイルを処理することになる。

.IP \-mount
ほかのファイルシステムにあるディレクトリを探索しない。これは \fB\-xdev\fP
の別名であり、系統の違う \fBfind\fP との互換性のためにある。

.IP \-noignore_readdir_race
\fB\-ignore_readdir_race\fP の効果を無効にする。

.IP \-noleaf
「ディレクトリのハードリンク数から 2 を引いたものが、そのディレクトリに含まれるサブディレクトリの数である」とする最適化動作を行わない。
このオプションが必要になるのは、ディレクトリとリンクの関係について
Unix の流儀に従わないファイルシステムを探索するときだ。たとえば、CD\-ROM や
MS\-DOS のファイルシステムとか、AFS ボリュームのマウントポイントなどを探索するときである。
通常の Unix ファイルシステムでは、各ディレクトリは少なくとも 2 個のハードリンクを持っている。
ディレクトリ名のエントリと、そのディレクトリ中の `.' エントリである。
さらに、そのディレクトリにサブディレクトリがあれば、
サブディレクトリそれぞれに、親ディレクトリにハードリンクした `..\&' エントリが存在する。
そこで、\fBfind\fP としては、ディレクトリを調べる際に、ディレクトリのハードリンク数より
2 だけ少ない数のサブディレクトリを stat 関数で調べた時点で、ディレクトリ中の残りのエントリはディレクトリではない
(ディレクトリツリー中の枝ではなく、「葉っぱ (leaf)]」ファイルである) とわかるわけだ。
もし、調べるのがファイル名だけで充分なら、ファイルに対して stat 関数を実行する必要はもうない。
そこで、この最適化動作によって、検索速度がいちじるしく向上するわけである。

.IP "\-version, \-\-version"
\fBfind\fP のバージョンを表示して終了する。

.IP \-xdev
ほかのファイルシステムにあるディレクトリを探索しない。

.SS "検査 (TESTS)"
検査の中には、たとえば \fB\-newerXY\fP や \fB\-samefile\fP
のように、現在検査の対象になっているファイルと、コマンドラインで指定したリファレンスファイルとを比較することになっているものがある。
そうしたリファレンスファイルが実際には何を指すかは、\fB\-H\fP, \fB\-L\fP, \fB\-P\fP
といったオプションや、先行する \fB\-follow\fP の存在によって決まってくる。
ただし、リファレンスファイルが調べられるのは、一回だけであり、それはコマンドラインの解析が行われるときである。
リファレンスファイルを調べることができない場合は (たとえば、それに対する \fBstat\fP(2)
システムコールに失敗するなど)、エラーメッセージが表示され、\fBfind\fP は
0 以外のステータスで終了する。
.P
数値の引き数は、以下の形で指定することができる。
.IP \fI+n\fP
\fIn\fP より大きい。
.IP \fI\-n\fP
\fIn\fP より小さい。
.IP \fIn\fP
ちょうど \fIn\fP。
.P

.IP "\-amin \fIn\fP"
ファイルの最終アクセス日時が \fIn\fP 分前であれば真を返す。

.IP "\-anewer \fIfile\fP"
ファイルの最終アクセス日時が、\fIfile\fP の内容更新日時よりも新しければ、真を返す。
引き数 \fIfile\fP がシンボリックリンクで、しかも \fB\-H\fP や \fB\-L\fP オプションが有効になっている場合は、
リンク先のファイルの内容更新日時が比較に使用されることになる。

.IP "\-atime \fIn\fP"
ファイルの最終アクセス日時が、基点となる時刻から計算して \fIn\fP 日前に当たれば、真を返す
(訳注: 基点となる時刻は、デフォルトでは \fBfind\fP を実行している今現在である)。
ファイルの最終アクセス日時が何日前かを計算する際、時間差を
24 時間で割って出た小数点以下の端数は無視される。従って、\fB\-atime\fP \fB+1\fP
にマッチするためには、ファイルは少なくとも二日前にアクセスされていなければならない。
(訳注: 1.5 日前は、1 日前と判定される。そして、\fB\-atime\fP \fB+1\fP は、2 日以上前である。
なお、デフォルトの動作のように、現在時刻から数えて 24 時間前から 48 時間前までを
1 日前とするのではなく、今日の午前 0 時以前の 24 時間 (つまり、日常的な意味での昨日)
を 1 日前として計算したいのなら、位置オプション \fB\-daystart\fP を \fB\-atime\fP
の前に置けばよい。)

.IP "\-cmin \fIn\fP"
ファイルの最終ステータス変更日時が \fIn\fP 分前ならば真。

.IP "\-cnewer \fIfile\fP"
ファイルの最終ステータス変更日時が、\fIfile\fP の内容更新日時よりも新しければ、真を返す。
引き数 \fIfile\fP がシンボリックリンクで、しかも \fB\-H\fP や \fB\-L\fP オプションが有効になっている場合は、
リンク先のファイルの内容更新日時が比較に使用されることになる。

.IP "\-ctime \fIn\fP"
ファイルの最終ステータス変更日時が、基点となる時刻から計算して \fIn\fP 日前に当たれば、真を返す
(訳注: 基点となる時刻は、デフォルトでは \fBfind\fP を実行している今現在である)。
何日前かを計算する際、時間差を 24 時間で割った結果を丸めるせいで、
ファイルのステータス変更日時の解釈にどんな影響が出るかについては、
\fB\-atime\fP の説明を参照していただきたい。
(訳注: 要するに、割り算の際に、小数点以下の端数を切り捨てるということ。
なお、デフォルトの動作のように、現在時刻から数えて 24 時間前から 48 時間前までを
1 日前とするのではなく、今日の午前 0 時以前の 24 時間 (つまり、日常的な意味での昨日)
を 1 日前として計算したいのなら、位置オプション \fB\-daystart\fP を \fB\-ctime\fP
の前に置けばよい。)

.IP \-empty
ファイルが空で、通常のファイルかディレクトリならば真。

.IP \-executable
実行可能なファイルや (ファイル名解決の見地から見て) 検索可能なディレクトリにマッチする。
検査 \fB\-perm\fP が ACL (アクセス・コントロール・リスト)
などのパーミッション制御の仕組みを無視するのに対して、この検査は ACL
なども考慮に入れる。この検査は \fBaccess\fP(2) システムコールを使用しているので、UID
マッピング (または root\-squashing) を行っている
NFS サーバがあると、正確な結果を得られないことがある。なぜなら、たいていのシステムでは
\fBaccess\fP(2) をクライアントのカーネルで実装しており、それ故、サーバ側に保持されている
UID マッピング情報を利用できないからだ。この検査はひとえに
\fBaccess\fP(2) システムコールの結果に基づいているので、
この検査が真を返したからと言って、そのファイルが実際に実行できるとはかぎらない。

.IP \-false
常に偽を返す。

.IP "\-fstype \fItype\fP"
ファイルが置かれているファイルシステムが \fItype\fP ならば、真を返す。
有効なファイルシステムは、Unix の系統によって様々である。
Unix の系統次第で指定可能なファイルシステムを不完全ながら挙げると、
ufs, 4.2, 4.3, nfs, tmp, mfs, S51K, S52K などがある。アクション \fB\-printf\fP
で書式指定子 %F を使えば、現在使用中のファイルシステムのタイプが何かを知ることができる。

.IP "\-gid \fIn\fP"
ファイルのグループ ID 番号が \fIn\fP ならば真。

.IP "\-group \fIgname\fP"
ファイルの属するグループが \fIgname\fP ならば真 (グループ ID 番号で指定してもよい)。

.IP "\-ilname \fIpattern\fP"
\fB\-lname\fP と同じだが、大文字小文字を区別しない。\fB\-L\fP や \fB\-follow\fP
オプションが有効な場合は、シンボリックリンクがリンク切れしている場合を除き、この検査は偽を返す。


.IP "\-iname \fIpattern\fP"
\fB\-name\fP と同じだが、大文字小文字を区別しない。
たとえば、パターン `fo*' や `F??' は、`Foo', `FOO', `foo', `fOo'
といったファイル名とマッチする。パターン `*foo*' は、`.foobar'
というファイルともマッチすることになる。

.IP "\-inum \fIn\fP"
ファイルの inode 番号が \fIn\fP ならば真。
たいていの場合、この検査より、\fB\-samefile\fP を使った方が簡単である。

.IP "\-ipath \fIpattern\fP"
\fB\-path\fP と同じだが、大文字小文字を区別しない。

.IP "\-iregex \fIpattern\fP"
\fB\-regex\fP と同じだが、大文字小文字を区別しない。

.IP "\-iwholename \fIpattern\fP"
\fB\-ipath\fP 参照。この別名は移植性で \fB\-ipath\fP に劣る。

.IP "\-links \fIn\fP"
ファイルのハードリンク数が \fIn\fP ならば真。

.IP "\-lname \fIpattern\fP"
ファイルがシンボリックリンクであり、リンク先として指定されているパスがシェルのパターン
\fIpattern\fP にマッチすれば、真を返す。メタ文字は、`/' や `.' を例外扱いしない。
\fB\-L\fP や \fB\-follow\fP オプションが有効な場合は、シンボリックリンクがリンク切れしている場合を除き、この検査は偽を返す。

.IP "\-mmin \fIn\fP"
ファイルの最終内容更新日時が \fIn\fP 分前であれば真。

.IP "\-mtime \fIn\fP"
ファイルの最終内容更新日時が、基点となる時刻から計算して \fIn\fP 日前に当たれば、真を返す
(訳注: 基点となる時刻は、デフォルトでは \fBfind\fP を実行している今現在である)。
何日前かを計算する際、時間差を 24 時間で割った結果を丸めるせいで、
ファイルの内容更新日時の解釈にどんな影響が出るかについては、
\fB\-atime\fP の説明を参照していただきたい。
(訳注: 要するに、割り算の際に、小数点以下の端数を切り捨てるということ。
なお、デフォルトの動作のように、現在時刻から数えて 24 時間前から 48 時間前までを
1 日前とするのではなく、今日の午前 0 時以前の 24 時間 (つまり、日常的な意味での昨日)
を 1 日前として計算したいのなら、位置オプション \fB\-daystart\fP を \fB\-mtime\fP
の前に置けばよい。)

.IP "\-name \fIpattern\fP"
ファイルやディレクトリのベースネーム (パスから最後の要素だけを残して、先行するディレクトリを取り去ったもの)
が、シェルのパターン \fIpattern\fP にマッチすれば、真を返す。検査 \fB\-name\fP
でマッチするかどうかを調べられるファイル名は、先行するディレクトリを除去したものだから、スラッシュが含まれることはない。従って、`\-name a/b'
は何にもマッチしないことになる (\fB\-name\fP ではなく、多分 \fB\-path\fP
を使う必要があるだろう)。そんなことをしようとすると、環境変数 POSIXLY_CORRECT
が設定されていない場合は、警告メッセージが出る。メタ文字 (`*', `?', `[]')
は、ベースネームの先頭にある `.' とマッチする
(findutils\-4.2.2 からこのように変更になった。下記のセクション「規格への準拠」を参照)。
あるディレクトリとそれ以下にあるファイルをまとめて無視するには、\fB\-prune\fP を使うとよい。
一例が \fB\-path\fP の説明中にある。波カッコ ('{}') は特殊文字として認識されない。
この点、bash を含む一部のシェルで、シェル・パターン中の波カッコに特別な意味を付与しているのと異なっている。
ファイル名のマッチングは、\fBfnmatch\fP(3) ライブラリ関数を用いて行われる。
パターンを引用符で囲むのを忘れないように。シェルによって展開されてしまわないようにするためである。

.IP "\-newer \fIfile\fP"
ファイルが \fIfile\fP よりも最近に内容を更新されていれば、真を返す。
引き数 \fIfile\fP がシンボリックリンクで、しかも \fB\-H\fP や \fB\-L\fP
オプションが有効になっている場合は、リンク先のファイルの内容更新日時が比較に使用されることになる。

.IP "\-newerXY \fIreference\fP"
検査対象ファイルのタイムスタンプの \fIX\fP 日時が、リフェレンスファイル
\fIreference\fP のタイムスタンプの \fIY\fP 日時より新しければ、真を返す。
\fIX\fP と \fIY\fP の位置に来る文字は、以下のどの文字でもよい。

.TS
ll
ll
ll
ll
llw(2i).
a	ファイルのアクセス日時
B	ファイルの作成日時
c	inode のステータスが変更された日時
m	ファイルの内容が更新された日時
t	\fIreference\fP が日時の直接表現として解釈される
.TE

組み合わせによっては、無効なものもある。たとえば、\fIX\fP に \fIt\fP を指定しても無効である。
組み合わせの中には、すべてのシステムで実装されているとはかぎらないものもある。
たとえば、\fIB\fP はすべてのシステムでサポートされているわけではない。
\fIXY\fP の無効な組み合わせやサポートされていない組み合わせを指定すると、致命的エラーが生じる。
日時を直接指定すると、それは GNU \fBdate\fP の \fB\-d\fP オプションに対する引き数と同じように解釈される。
リファレンスファイルの作成日時を使用しようとした場合に、作成日時が特定できないと、致命的エラーのメッセージが出力される。
また、検査対象ファイルの作成日時を参照する検査を指定した場合に、
作成日時がわからない環境では、その検査はいかなるファイルに対しても失敗することになる
(訳注: この場合、失敗するというのは、検査が偽になることではなく、エラーになることのようだ。ご自分の環境で確かめていただきたい)。

.IP \-nogroup
ファイルのグループ ID 番号に対応するグループが、システムに存在しない場合に、真を返す。

.IP \-nouser
ファイルのユーザ ID 番号に対応するユーザが、システムに存在しない場合に、真を返す。

.IP "\-path \fIpattern\fP"
ファイル名がシェルのパターン \fIpattern\fP にマッチすれば、真を返す。
メタ文字は、`/' や `.' を例外扱いしない。従って、たとえば、
.br
.in +1i
find . \-path "./sr*sc"
.br
.in -1i
は、`./src/misc' というディレクトリを (存在していれば) 表示することになる。
あるディレクトリ以下をすべて無視するには、そこに存在するファイルを一つ一つ抑止するよりも、\fB\-prune\fP
を使用した方がよい。たとえば、ディレクトリ `src/emacs'
と、その下にあるファイルやディレクトリのすべてをスキップし、それ以外のファイルが見つかったら、その名前を表示するとしよう。そのためには、こんな風にする。
.br
.in +1i
find . \-path ./src/emacs \-prune \-o \-print
.br
.in -1i
パターンマッチの検査は、パスを含むファイル名の全体に対して行われるが、
そうしたファイル名は、コマンドラインで指定した探索開始点の一つから始まっていることに注意してしていただきたい。
だから、\fB\-path\fP の引き数に絶対パス名を使用することに意味があるのは、
関連する探索開始点がこちらも絶対パスであるときだけだろう。
従って、次のコマンドは 何にもマッチしないことになる。
.br
.in +1i
find bar \-path /foo/bar/myfile \-print
.br
.in -1i
\fBfind\fP は、\fB\-path\fP の引き数を、目下検査してるファイルのディレクトリ名とベースネームを連結したものと比較する。
その連結したものの末尾がスラッシュになることは絶対にないので、スラッシュで終わる
\fB\-path\fP の引き数は、何にもマッチしないことになる
(ただし、コマンドラインで指定された探索開始点となら、場合によってはマッチするかもしれないが)。
\fB\-path\fP という述語は、HP\-UX の \fBfind\fP でもサポートされており、
POSIX 規格の次期バージョンでも採用されることになるだろう
(訳注: 実際に POSIX 2008 で採用されている)。

.IP "\-perm \fImode\fP"
ファイルの許可属性が \fImode\fP (8 進数表現でもシンボル表現でもよい) とまったく同じなら、真を返す。
\fImode\fP 指定のこの形式では、許可属性がぴったり一致することを要求することになるので、
シンボルによる表現でこの形式を使おうとすると、かなり複雑なモード文字列を指定しなければならないかもしれない。
たとえば `\-perm g=w' は、許可属性が 0020 のファイルにしかマッチしない
(すなわち、許可属性のうち、グループの書き込み許可のみが立っているファイルだ)。
従って、\fImode\fP の前に `/' や `\-' を付ける形式を使いたくなることの方が、多分多いだろう。
たとえば、`\-perm \-g=w' とすれば、グループの書き込み許可があるファイルなら、どんなファイルにもマッチすることになる。
具体例については「用例」セクションをご覧いただきたい。

.IP "\-perm \-\fImode\fP"
\fImode\fP で指定した許可属性ビットのすべてが、ファイルでも立っていれば、真を返す。
\fImode\fP 指定のこの形式でも、シンボルによる許可属性表現が使用できる。
そこで、この形式ではシンボルによる表現を使いたくなることが多いだろう。
シンボルによる表現を使用する場合は、`u' や `g' や `o' を きちんと指定しなければならない。
具体例については「用例」セクションをご覧いただきたい。

.IP "\-perm /\fImode\fP"
\fImode\fP で指定した許可属性ビットのどれかが、ファイルでも立っていれば、真を返す。
\fImode\fP 指定のこの形式でも、シンボルによる許可属性表現が使用できる。
シンボルによる表現を使用する場合は、`u' や `g' や `o' をきちんと指定しなければならない。
具体例については「用例」セクションをご覧いただきたい。なお、\fImode\fP
で許可属性ビットが一つも立っていない場合、この検査はいかなるファイルにもマッチすることになる
(これは、\fB\-perm\fP \fB\-000\fP と動作に一貫性を持たせるための変更である。
(訳注: \fB\-perm\fP \-\fImode\fP と \fB\-perm\fP /\fImode\fP
のどちらの指定法においても、0 は何であってもよいを意味するようにしたということ))。

.IP "\-perm +\fImode\fP"
この形式は、今ではサポートされていない (2005 年以来、非推奨だった）。
代わりに \fB\-perm /\fP\fImode\fP を使用すること。

.IP \-readable
読み込み可能なファイルにマッチする。検査 \fB\-perm\fP が
ACL (アクセス・コントロール・リスト) などのパーミッション制御の仕組みを無視するのに対して、この検査は ACL なども考慮に入れる。
この検査は \fBaccess\fP(2) システムコールを使用しているので、UID マッピング (または root\-squashing)
を行っている NFS サーバがあると、正確な結果を得られないことがある。なぜなら、たいていのシステムでは
\fBaccess\fP(2) をクライアントのカーネルで実装しており、それ故、サーバ側に保持されている
UID マッピング情報を利用できないからである。

.IP "\-regex \fIpattern\fP"
ファイル名が正規表現 \fIpattern\fP にマッチすれば、真を返す。
これはパスを含むファイル名全体に対するマッチであって、ベースネームの検索ではない。
だから、たとえば、`./fubar3' という名前のファイルにマッチさせるために、
正規表現 `.*bar.' や `.*b.*3' は使用できるが、`f.*r3' は使用できない。
\fBfind\fP が理解する正規表現は、デフォルトでは Emacs の正規表現だが、
これは \fB\-regextype\fP オプションで変更することができる。

.IP "\-samefile \fIname\fP"
ファイルが \fIname\fP と同じ inode を参照していれば、真を返す。 \fB\-L\fP が有効な場合、シンボリックリンクも真を返す。

.IP "\-size \fIn\fP[cwbkMG]"
ファイルが \fIn\fP 単位分の領域を使用していれば、真を返す
(対象となるファイルのサイズを、単位にまで切り上げて比較する)。以下の接尾辞が使える。
.RS
.IP "[\fB訳注\fP]:" 8
ブロック数を指定するときは、注意していただきたい。
\fB\-size\fP では、検査対象ファイルのブロック数の算出を、単にファイルのサイズを 
512 で割り、その結果を切り上げて整数にすることで行っている。
これは、\fBstat\fP コマンドの出力や POSIXLY_CORRECT が設定されているときの 
\fBls \-s\fP の結果と、同じではないことが多い。\fBstat\fP や \fBls\fP 
は、ファイルに対するディスクスペースの割当が、ファイルシステムのブロックサイズ 
(ext4 なら、たいてい 4096 バイト、つまり 8 ブロック) 
の倍数で行われることを考慮に入れているのである。なお、アクション 
\fB\-printf\fP における `%b' の出力は、\fBstat\fP などと同じである。
.IP `b'
単位はブロック。1 ブロックは 512 バイト。(これが接尾辞を使わないときの デフォルトである)
.IP `c'
単位はバイト。
.IP `w'
単位はワード。1 ワードは 2 バイト。
.IP `k
単位はキビバイト (1 キビバイトは 1024 バイト)。
.IP `M'
単位はメビバイト (1 メビバイトは 1048576 バイト)。
.IP `G'
単位はギビバイト (1 ギビバイトは 1073741824 バイト)。
.RE
.IP
サイズには間接ブロック (indirect block) の分は含まれないが、穴空きファイル
(sparse file) における、実際には割り当てられていないブロックの分は含まれる。
アクション \fB\-printf\fP の `%k' や `%b' 書式指定子とは、穴空きファイルの扱い方が違うことを心にとめておいていただきたい。
また、接尾辞 `b' は常に 512 バイトのブロックを意味し、1 キロバイトのブロックを指すことはない。
その点で、アクション \fB\-ls\fP の動作とは異なっている。
数値の前に + や \- を付けると、他の場合と同様、「より大きい」や「より小さい」を意味することになるが、
ファイルのサイズは、単位以下の部分が、単位にまで切り上げられることに留意していただきたい
(だから、1 byte のファイルは、\fB\-size \-1M\fP にマッチしない。(訳注: \fB\-size 1M\fP とならマッチする))。
.IP \-true
常に真。

.IP "\-type \fIc\fP"
ファイルのタイプが \fIc\fP であれば真。(訳注: \fIc\fP の位置には実際には以下の文字が来る。)
.RS
.IP b
ブロック・スペシャルファイル (バッファあり)
.IP c
キャラクタ・スペシャルファイル (バッファなし)
.IP d
ディレクトリ
.IP p
名前付きパイプ (FIFO)
.IP f
通常のファイル
.IP l
シンボリックリンク。オプション \fB\-L\fP や \fB\-follow\fP が有効な場合、
シンボリックリンクがリンク切れの場合を除いて、この検査が真になることはない。
\fB\-L\fP が有効なときにシンボリックリンクを検索したかったら、\fB\-xtype\fP を使うべきである。
.IP s
ソケット
.IP D
ドア (Solaris の場合)
.RE
.IP "\-uid \fIn\fP"
ファイル所有者のユーザ ID 番号が \fIn\fP ならば真。

.IP "\-used \fIn\fP"
ファイルが最後にアクセスされたのが、ファイルの最終ステータス変更日時より
\fIn\fP 日後ならば、真を返す。

.IP "\-user \fIuname\fP"
ファイルの所有者が \fIuname\fP というユーザならば真 (ユーザ ID 番号で指定してもよい)。

.IP "\-wholename \fIpattern\fP"
\fB\-path\fP と同じである。この別名は移植性で \fB\-path\fP に劣る。

.IP \-writable
書き込み可能なファイルにマッチする。検査 \fB\-perm\fP が ACL
(アクセス・コントロール・リスト) などのパーミッション制御の仕組みを無視するのに対して、
この検査は ACL なども考慮に入れる。この検査は \fBaccess\fP(2)
システムコールを使用しているので、UID マッピング (または root\-squashing)
を行っている NFS サーバがあると、正確な結果を得られないことがある。なぜなら、たいていのシステムでは
\fBaccess\fP(2) をクライアントのカーネルで実装しており、それ故、サーバ側に保持されている
UID マッピング情報を利用できないからである。

.IP "\-xtype \fIc\fP"
検査の対象となるファイルがシンボリックリンクでないかぎり、\fB\-type\fP と同じである。
ファイルがシンボリックリンクのときは、以下のように動作する。
\fB\-H\fP や \fB\-P\fP オプションが指定された場合は、タイプが \fIc\fP
のファイルに対するリンクならば、真を返す。また、\fB\-L\fP
オプションが指定されている場合は、\fIc\fP が `l' ならば、真を返す。
言い換えると、ファイルがシンボリックであるとき、\fB\-xtype\fP
は、\fB\-type\fP がチェックしない方のファイルのタイプをチェックするわけだ。
.IP "\-context \fIpattern\fP"
(SELinux が有効なときのみ) ファイルのセキュリティ・コンテキストが
glob のパターン (訳注: つまり、シェル式のパターン)
\fIpattern\fP にマッチすれば、真を返す。

.SS アクション
.IP \-delete
ファイルを消去する。消去に成功すれば、真を返す。
消去に失敗した場合は、エラーメッセージを表示する。
\fB\-delete\fP に失敗した場合の \fBfind\fP の終了ステータスは、ゼロ以外である
(\fBfind\fP が最終的に終了したときの終了ステータスのことだ)。\fB\-delete\fP
を使用すると、自動的に `\fB\-depth\fP' オプションが有効になる。

\fB警告\fP: 忘れないでいただきたいが、find のコマンドラインは一つの式 (expression)
として評価されるので、一番最初に \fB\-delete\fP を指定すると、
\fBfind\fP は、指定された探索の開始点以下にあるものを、ことごとく消去しようとする。
後で \fB\-delete\fP を付けて使用するつもりで、\fBfind\fP
のコマンドラインをテスト実行するときは、\fB\-depth\fP を明示的に指定するとよい。
そうすれば、後で「こんなはずではなかった」と慌てないですむ。
\fB\-delete\fP を指定すると自動的に \fB\-depth\fP が有効になるので、\fB\-prune\fP
を \fB\-delete\fP と一緒に使っても役に立たない。

.IP "\-exec \fIcommand\fP ;"
\fIcommand\fP を実行する。\fIcommand\fP の返り値が 0 ならば、真を返す。
\fBfind\fP のコマンドラインで指定されているこれ以降の引き数は、`;' という引き数が現れるまで、すべてコマンドに対する引き数と見なされる。
文字列 `{}' は、それがコマンドの引き数中に現れるすべての場所で、現在処理中のファイル名に置き換えられる。
\fBfind\fP の一部の版とは違い、`{}' は引き数中の一ヶ所でしか使えないわけではない。
こうした構文の要素 (訳注: すなわち、`{}' や `;') は、シェルによって展開されないように、
どちらも `\e' でエスケープするなり、引用符で囲むなりする必要があるかもしれない。
アクション \fB\-exec\fP の使用例については「用例」セクションを見ていただきたい。
指定したコマンドは、マッチした各ファイルに対して一回づつ実行される。
また、コマンドは \fBfind\fP を実行したディレクトリで実行される。
そこで、\fB\-exec\fP アクションの使用を巡っては、セキュリティの問題が避けられないわけであり、
\fB\-exec\fP の代わりに、\fB\-execdir\fP アクションを使用することをお勧めする。
(訳注: `;' は引き数なので、直前の引き数との間に空白が必要だということに注意していただきたい。)

.IP "\-exec \fIcommand\fP {} +"
アクション \fB\-exec\fP のこの変形も、選択したファイルに対して指定したコマンドを実行するが、
コマンドラインを形成するとき、選択した各ファイル名をコマンドラインの末尾に追加して行くという方法を取る
(訳注: コマンドラインが長くなりすぎるときは、処理するファイル名のリストを適宜分割して、コマンドを複数回実行する)。
そのため、コマンドを呼び出す回数が、マッチしたファイルの数よりずっと少なくてすむ。
コマンドラインの形成法は、 \fBxargs\fP のコマンドライン形成法とほぼ同じである。
`{}' はコマンドライン中の一ヶ所でしか使えない。
なお、コマンドは \fBfind\fP を実行したディレクトリで実行される。
\fBfind\fP がエラーに出会うと、このアクションは \fBfind\fP をその場で終了させてしまうことがあり、
そのため、予定されているコマンドの中に全く実行されないものが生ずるかもしれない。
\fB\-exec\fP のこの変形は、常に真を返す。
(訳注: `+' は引き数なので、直前の引き数との間に空白が必要だということに注意していただきたい。)

.IP "\-execdir \fIcommand\fP ;"
.IP "\-execdir \fIcommand\fP {} +"
\fB\-exec\fP と似ているが、指定したコマンドを、マッチしたファイルが存在するサブディレクトリで実行するという点が異なっている。
そのサブディレクトリは、 \fBfind\fP を実行したディレクトリとは違うのが普通だ。
これはコマンドを呼び出す方法としてずっと安全である。マッチしたファイルのパスを解決する際に、競合状態が起きるのを避けられるからだ。
アクション \fB\-exec\fP の場合と同様、 \fB\-execdir\fP の `+' を伴う形式でも、
マッチした複数のファイルを一度に処理するように、コマンドラインを形成することになるが、
\fIcommand\fP のどの呼び出しにおいても、処理の対象としてリストされるファイルは、同じサブディレクトリに存在するものだけである。
このアクションを使用するのなら、環境変数 \fB$PATH\fP が `.' を参照しないようにしなければならない。
さもないと、悪意を持った攻撃者が、あなたが \fB\-execdir\fP を実行することになるディレクトリに適当な名前のファイルを入れておくことによって、
何でも好きなコマンドを実行できてしまうからだ。
\fB$PATH\fP の中に、空っぽのエントリや、絶対パスのディレクトリ名ではないエントリがある場合にも、同じことが言える。
\fBfind\fP がエラーに出会うと、このアクションは \fBfind\fP をその場で終了させてしまうことがあり、
そのため、予定されているコマンドの中に全く実行されないものが生ずるかもしれない。
このアクションが返す値は、\fB+\fP と \fB;\fP のどちらを使うかによって異なっている。
\fB\-execdir\fP \fIcommand\fP \fB{} +\fP が常に真を返すのに対して、\fB\-execdir\fP \fIcommand\fP \fB{} ;\fP
は、\fIcommand\fP が 0　を返したときのみ、真を返すのである。


.IP "\-fls \fIfile\fP"
真を返す。\fB\-ls\fP と似ているが、\fB\-fprint\fP 同様、出力を \fIfile\fP に書き出す点が違う。
出力用のファイルは、この述語の対象になるものが一つもなかった場合でも、必ず作成される。
ファイル名中の普通使わない文字がどのように扱われるかについては、「変わり者のファイル名」セクションを参照していただきたい。

.IP "\-fprint \fIfile\fP"
真を返す。パス付きのファイル名をファイル \fIfile\fP に出力する。
\fBfind\fP の実行時に \fIfile\fP が存在しなければ、新たに作成される。
すでに存在していれば、元の中身が捨てられる。ファイル名 `/dev/stdout' と
`/dev/stderr' の扱いは特別で、それぞれ標準出力と標準エラー出力を指している。
出力用のファイルは、この述語の対象になるものが一つもなかった場合でも、必ず作成される。
ファイル名中の普通使わない文字がどのように扱われるかについては、「変わり者のファイル名」セクションを参照していただきたい。

.IP "\-fprint0 \fIfile\fP"
真を返す。\fB\-print0\fP と似ているが、\fB\-fprint\fP 同様、出力を \fIfile\fP に書き出す点が違う。
出力用のファイルは、この述語の対象になるものが一つもなかった場合でも、必ず作成される。
ファイル名中の普通使わない文字がどのように扱われるかについては、「変わり者のファイル名」セクションを参照していただきたい。

.IP "\-fprintf \fIfile\fP \fIformat\fP"
真を返す。\fB\-printf\fP と似ているが、 \fB\-fprint\fP 同様、出力を \fIfile\fP に書き出す点が違う。
出力用のファイルは、この述語の対象になるものが一つもなかった場合でも、必ず作成される。
ファイル名中の普通使わない文字がどのように扱われるかについては、「変わり者のファイル名」セクションを参照していただきたい。

.IP \-ls
真を返す。処理対象のファイルを \fBls \-dils\fP の書式で標準出力にリストする。
ブロック数は、1 ブロック 1 キロバイトの計算である。
ただし、環境変数 POSIXLY_CORRECT が設定されている場合は、1 ブロック 512 バイトが使用される。
ファイル名中の普通使わない文字がどのように扱われるかについては、「変わり者のファイル名」セクションを参照していただきたい。

.IP "\-ok \fIcommand\fP ;"
\fB\-exec\fP と似ているが、まずユーザに問い合わせを行う。
ユーザーが同意すれば、コマンドを実行する。同意しなければ、何もせずに偽を返す。
コマンドを実行する場合、そのコマンドの標準入力は、\fB/dev/null\fP に付け換えられる。

.IP
プロンプトに対するユーザの応答は、肯定・否定を表す一組の正規表現と照合して、同意か、不同意かが判断される。
この正規表現は、環境変数 `POSIXLY_CORRECT' が設定されていれば、システムから得られるが、
設定されていなければ、\fBfind\fP の持つメッセージ翻訳から取得される。
なお、システムに適切な定義が存在しない場合は、 \fBfind\fP の持つ定義が使用されることになる。
どちらの場合でも、正規表現そのものの解釈は、環境変数 'LC_CTYPE' (文字クラスについて) や
\&'LC_COLLATE' (文字の範囲や等価クラスについて) の影響を受ける。



.IP "\-okdir \fIcommand\fP ;"
\fB\-execdir\fP と似ているが、\fB\-ok\fP と同じように、まずユーザに問い合わせを行う。
ユーザが同意しなければ、何もせずに偽を返す。
コマンドを実行する場合、そのコマンドの標準入力は、\fB/dev/null\fP に付け換えられる。

.IP \-print
真を返す。パス付きのファイル名を標準出力に表示し、各ファイル名の後ろに改行文字を付ける。
\fBfind\fP の出力をパイプを使って他のプログラムに渡している場合、
検索対象のファイル名に改行文字が含まれている可能性が、わずかにでもあるならば、
\fB\-print\fP ではなく、 \fB\-print0\fP アクションを使用することを真剣に考えるべきだ。
ファイル名中の普通使わない文字がどのように扱われるかについては、「変わり者のファイル名」セクションを参照していただきたい。

.IP \-print0
真を返す。パス付きのファイル名を標準出力に表示し、各ファイル名の後ろに
(\fB\-print\fP が改行文字を付けるのとは違って) ヌル文字を追加する。
このアクションを使えば、\fBfind\fP の出力を処理するプログラムが、改行文字などのホワイトスペースを含むファイル名を正しく解釈できるようになる。
このアクションは、\fBxargs\fP の \fB\-0\fP オプションに呼応している。

.IP "\-printf \fIformat\fP"
真を返す。標準出力に \fIformat\fP を表示する。そのとき \fIformat\fP 中の
`\e' によるエスケープシーケンスと、`%' に始まる書式指定子を認識して変換する。
フィールドの幅や精度は、C 言語の `printf' 関数と同じ方法で指定できる。
%d ではなく、%s として (訳注: すなわち、数値ではなく、文字列として)
表示されるフィールドが多いことに注意していただきたい。
そのため、フラグが期待通りに効かないかもしれないのだ。
ただし、`\-' フラグ (フィールドを強制的に左揃えにする)
はきちんと働くということでもある。\fB\-print\fP とは違って、
\fB\-printf\fP は文字列の末尾に改行文字を追加しない。
バックスラッシュ・エスケープシーケンスと書式指定子は以下のとおりである。
.RS
.IP \ea
警告ベル。
.IP \eb
バックスペース。
.IP \ec
このフォーマットによる出力をただちに停止し、出力をフラッシュする。
.IP \ef
フォームフィード文字。
.IP \en
改行文字。
.IP \er
復帰文字。
.IP \et
水平タブ。
.IP \ev
垂直タブ。
.IP \e0
ASCII NUL 文字。
.IP \e\e
バックスラッシュ文字そのもの (`\e')。
.IP \eNNN
ASCII コードが NNN (8 進数) の文字。
.PP
バックスラッシュ文字 `\e' に上記以外の文字が続く場合、`\e' は普通の文字として扱われる。
従って、二文字とも表示されることになる。
.IP %%
パーセント文字そのもの。
.IP %a
ファイルの最終アクセス日時を C 言語の `ctime' 関数が返す形式で表示する。
.IP %A\fIk\fP
ファイルの最終アクセス日時を \fIk\fP で指定した書式で表示する。\fIk\fP には
`@' か、あるいは C 言語の `strftime' 関数の書式指定子を用いる。
\fIk\fP に指定可能な値を以下に列挙する。
一部のものは使えないシステムがあるかもしれないが、それはシステム間での
`strftime' の非互換性による。
.RS
.IP @
Jan. 1, 1970, 00:00 GMT からの経過秒数。小数点以下も表示する。
.PP
時刻フィールド:
.IP H
時 (00..23)
.IP I
時 (01..12)
.IP k
時 ( 0..23)
.IP l
時 ( 1..12)
.IP M
分 (00..59)
.IP p
現在のロケールにおける AM/PM の相当語
.IP r
12 時間制の時刻 (hh:mm:ss [AP]M)
.IP S
秒 (00.00 .. 61.00)。小数点以下も表示。
.IP T
24 時間制の時刻 (hh:mm:ss)
.IP +
日付と時刻。両者の間は `2004\-04\-28+22:22:05.0' といった具合に '+' で 区切られる。
これは GNU の拡張である。日時は現在のタイムゾーンのものが使われる
(それ故、環境変数 TZ の設定によって変わるかもしれない)。秒には小数点以下も付く。
.IP X
現在のロケールによる時刻表示 (H:M:S)
.IP Z
タイムゾーン (JST など)。タイムゾーンを決定できない場合は、何も表示しない。
.PP
日付フィールド:
.IP a
現在のロケールによる曜日の短縮形 (Sun..Sat)
.IP A
現在のロケールによる曜日の省略しない表示。長さは可変 (Sunday..Saturday)
.IP b
現在のロケールによる月名の短縮形 (Jan..Dec)
.IP B
現在のロケールによる月名の省略しない表示。長さは可変 (January..December)
.IP c
現在のロケールによる日付と時刻の表示 (Sat Nov 04 12:02:33 EST 1989)。
この表示形式は \fBctime\fP(3) のものと同じであり、\fBctime\fP(3)
の形式との互換性を維持するためにそうなっている。秒には小数点以下が付かない。
.IP d
その月の何日目かの表示 (01..31)
.IP D
日付 (mm/dd/yy)
.IP h
b と同じ
.IP j
その年の何日目かの表示 (001..366)
.IP m
月 (01..12)
.IP U
その年の何週目か (日曜日を週の始まりとする) (00..53)
.IP w
曜日 (0..6)
.IP W
その年の何週目か (月曜日を週の始まりとする) (00..53)
.IP x
現在のロケールによる日付表示 (mm/dd/yy)
.IP y
年の下二桁 (00..99)
.IP Y
年 (1970...)
.RE
.IP %b
ファイルのディスクスペース使用量を 1 ブロック 512 バイトのブロック数で表示する。
ディスクスペースは、ファイルシステムのブロックサイズの倍数で割り当てられるので、この表示はたいてい
%s/512 より大きい。だが、ファイルが穴空きファイル (sparse file)
の場合は、%s/512 より小さくなることもある。
.IP %c
ファイルの最終ステータス変更日時を C 言語の `ctime' 関数が返す形式で表示する。
.IP %C\fIk\fP
ファイルの最終ステータス変更日時を \fIk\fP で指定した書式で表示する。
\fIk\fP は %A の場合と同じである。
.IP %d
ファイルがディレクトリツリー中でどの深さにあるかを示す。
0 だったら、そのファイルが探索開始点だということだ。
.IP %D
ファイルがどのデバイス上にあるかを十進数のデバイス番号で示す
(stat 構造体の st_dev フィールドに当たる)。
.IP %f
先行するディレクトリをすべて取り去ったファイル名
(すなわち、最後の要素のみ表示)。
.IP %F
ファイルが置かれているファイルシステムのタイプ。ここで表示された値は
\-fstype の引き数に指定することができる。
.IP %g
ファイルのグループ名。該当するグループ名が存在しない場合は、グループ ID 番号。
.IP %G
ファイルのグループ ID 番号。
.IP %h
ファイル名中の先行するディレクトリの部分 (すなわち、最後の要素以外のすべて)。
ファイル名にスラッシュが一つも含まれない場合は
(それは、カレントディレクトリ中にあるということだから)、%h 書式指定子は
"." に展開される。
.IP %H
探索開始点のうち、その下に問題のファイルが見つかったもの。
.IP %i
ファイルの inode 番号 (十進数表示)。
.IP %k
ファイルのディスクスペース使用量を 1 ブロック 1 キロバイトのブロック数で表示する。
ディスクスペースは、ファイルシステムのブロックサイズの倍数で割り当てられるので、この表示はたいてい %s/1024 より大きい。
だが、ファイルが穴空きファイル (sparse file) の場合は、%s/1024 より小さくなることもある。
.IP %l
シンボリックリンクの参照先 (ファイルがシンボリックリンクでなかったら、空文字列)。
.IP %m
ファイルの許可属性ビット (8 進数表示)。このオプションが使用している数値は、
Unix のたいていの実装が使用している「伝統的な」数値である。
しかし、ご使用のシステムの実装では、8 進数で表示する許可属性ビットの並び方が独特かもしれない。
その場合は、ファイルの許可属性の実際の値と %m の出力とが、相違することになる。
この数値の先頭に 0 を付けて表示したいこともよくあるが、
そのためには、\fB#\fP フラグを使用すればよい (たとえば、`%#m' といった具合に)。
.IP %M
ファイルの許可属性 (\fBls\fP と同様のシンボルによる表現)。この書式指定子は findutils 4.2.5 以来 サポートされている。
.IP %n
ファイルのハードリンク数。
.IP %p
ファイル名。
.IP %P
問題のファイルが、ある探索開始点の下にあった場合に、
ファイル名から探索開始点を示す部分を取り去ったもの。
.IP %s
バイトで表示したファイルサイズ。
.IP %S
ファイルの穴空き率 (sparseness)。この値は、(BLOCKSIZE*st_blocks / st_size)
で計算される。ある大きさの普通のファイルから得られる値は、厳密に言うと、システム依存である。
それでも、穴空きファイルの穴空き率は、通常 1.0 未満になるし、
間接ブロックを使用しているファイルの穴空き率は、1.0 以上になることがある。
BLOCKSIZE に使われる値は、システム次第だが、普通は 512 バイトである。
ファイルサイズが 0 の場合、出力される値は不定である。
st_blocks をサポートしていないシステムでは、ファイルの穴空き率は、1.0 と見なされる。
.IP %t
ファイルの最終内容更新日時を、C 言語の `ctime' 関数が返す形式で表示する。
.IP %T\fIk\fP
ファイルの最終内容更新日時を \fIk\fP で指定した書式で表示する。
\fIk\fP は %A の場合と同じである。
.IP %u
ファイルの所有者名。該当するユーザ名が存在しない場合は、ユーザ ID 番号。
.IP %U
ファイルのユーザ ID 番号。
.IP %y
ファイルのタイプ (\fBls \-l\fP の表現とほぼ同じ)。U=unknown type
(これが表示されることはないはずだ）
.IP %Y
ファイルのタイプ (表示は %y と同じ)。ただし、シンボリックリンクをたどる。
その場合、L=loop, N=nonexistent である。
.IP %Z
(SELinux が有効なときのみ) ファイルのセキュリティ・コンテクスト。
.IP "%{ %[ %("
将来の使用のために予約されている。
.PP
一個の `%' に上記以外の文字が続く場合、`%' 文字は捨てられるが、それに続く文字は表示される
(書式指定文字が新たに追加されるかもしれないので、この動作を当てにしてはいけない。
(訳注: 以前はそのとおりだったが、現在では、無効な書式指定子を使った場合、`%q'
のように `%' も表示されるようだ))。
書式指定の末尾に `%' があるときの動作は、続く文字がないので不定である。
ロケールによっては、お宅のドアの鍵が見つからなくなるかもしれない。
また、別のロケールでは、お読みになっている小説の最後のページが消えてしまうかもしれない。

書式指定子 %m と %d はフラグ \fB#\fP, \fB0\fP, \fB+\fP をサポートするが、
それ以外の書式指定子では、数値を表示する場合でも、そうしたフラグをサポートしない。
\fB#\fP などをサポートしない数値関係の書式指定子には、\fBG\fP, \fBU\fP, \fBb\fP, \fBD\fP,
\fBk\fP, \fBn\fP などがある。しかし、書式フラグ `\-' はサポートされており、フィールドを
(デフォルトの) 右揃えから左揃えに変更する。
.PP
ファイル名中の普通使わない文字がどのように扱われるかについては、
「変わり者のファイル名」セクションの説明を参照していただきたい。


.RE
.IP \-prune
真を返す。処理対象のファイルがディレクトリの場合は、そのディレクトリ以下に降りて行かない。
\fB\-depth\fP が指定してあると、\fB\-prune\fP は、
偽を返し、その効果を失う。\fB\-delete\fP を指定すると自動的に \fB\-depth\fP
が有効になるので、\fB\-prune\fP を \fB\-delete\fP と一緒に使っても役に立たない。

.RS
.IP "[\fB訳注\fP]:" 8
つまり、\fB\-prune\fR は指定されたディレクトリの、いわゆる枝刈り 
(prune) をする。バージョン 4.3.11 以降の \fBfind\fR では、\fB\-prune\fR 
の動作が、上の説明と少し違っている。\fB\-depth\fR 
が指定してあると、\fB\-prune\fR が効果を失う (すなわち、枝刈りを行わなくなる) 
ことは、それ以前と変わりがないが、\fI返り値は真を返すようになっているのだ\fR。
これは POSIX 準拠の動作である。ご自分で、
.B find . \-depth \-path \(dq./foo\(dq \-prune \-print
などを実行して、確認していただきたい。\fB\-prune\fR 
が真を返していれば、ディレクトリ \fB./foo\fR が表示されるはずである。
.RE
.IP \-quit
直ちに終了する。動いている子プロセスを残したまま終了したりはしないが、コマンドラインで指定したパスをこれ以上処理することはない。
たとえば、 \fBfind /tmp/foo /tmp/bar \-print \-quit\fP は、\fB/tmp/foo\fP を表示するだけである。
\fB\-execdir \&...\& {} +\fP によってすでに作成されたコマンドラインがあれば、
\fBfind\fP が終了する前に、呼び出して実行する。
終了ステータスは、 エラーがすでに起きているかどうかよって、0 のことも、0 でないこともある。

.SS 演算子
.P
演算子を優先順位の高いものから順に列挙する。

.IP "( \fIexpr\fP )"
カッコの内側を先に処理する。カッコはシェルにとって特別な意味を持っているので、普通はクォートする必要があるだろう。
このマニュアルページで挙げている例の多くでは、そのためにバックスラッシュを使っている。
すなわち `(...)' ではなく、`\e(...\e)' と書いている。

.IP "! \fIexpr\fP"
\fIexpr\fP が偽の場合、真になる。
通常、この記号もシェルによって解釈されないようにする必要があるだろう。

.IP "\-not \fIexpr\fP"
! \fIexpr\fP と同じだが、POSIX 準拠の表現ではない。

.IP "\fIexpr1 expr2\fP"
連続する二つの式は、and 結合と解釈される (明示されていないが、式の間に
"\-a" があると見なされるわけだ)。\fIexpr1\fP が偽の場合、\fIexpr2\fP は評価されない。

.IP "\fIexpr1\fP \-a \fIexpr2\fP"
\fIexpr1 expr2\fP と同じ。

.IP "\fIexpr1\fP \-and \fIexpr2\fP"
\fIexpr1 expr2\fP と同じだが、POSIX 準拠の表現ではない。

.IP "\fIexpr1\fP \-o \fIexpr2\fP"
or 結合である。\fIexpr1\fP が真ならば、\fIexpr2\fP は評価されない。

.IP "\fIexpr1\fP \-or \fIexpr2\fP"
\fIexpr1\fP \fB\-o\fP \fIexpr2\fP と同じだが、POSIX 準拠の表現ではない。

.IP "\fIexpr1\fP , \fIexpr2\fP"
リストである。常に \fIexpr1\fP と \fIexpr2\fP の両方が評価される。
\fIexpr1\fP の値は捨てられ、\fIexpr2\fP の値がリスト全体の値になる。
コンマ演算子はいくつかの異なったタイプの対象を捜すとき便利だが、ファイルシステム階層の探索は一度しか行われない。
異なった形でマッチした対象の一覧をそれぞれ別の出力ファイルに書き出すには、\fB\-fprintf\fP アクションを利用すればよい。


.IP "[\fB訳注\fR]:" 8
.B find
にとって演算子も引き数である。だから `(', `)', `!', `,' といった演算子も、
前後の引き数との間に空白が必要だということに気をつけていただきたい。
.SH 変わり者のファイル名
多くの場合 \fBfind\fP のアクションは、他のユーザが自由にできるデータを端末に表示することになる。
そうしたデータには、 たとえば、ファイルの名前、サイズ、内容更新日時などがある。
この内、ファイル名は `\e0' と `/' 以外のどんな文字でも使えることになっているので、時として問題の種となる。
ファイル名の中に普通は使わない文字があると、使用している端末に思いがけない、そしてしばしば望ましくない影響をもたらすことがあるのだ (たとえば、
端末によっては、ファンクション・キーの現在の設定が変更されてしまう)。
普通使わない文字をどう扱うかはアクションによって異なっている。それを以下に示そう。

.IP "\-print0, \-fprint0"
常にファイル名に手を加えず、そのまま出力する。出力先が端末であっても、同じである。

.IP "\-ls, \-fls"
普通使わない文字は、常にエスケープされる。ホワイトスペース
(空白、改行、タブなど)、バックスラッシュ、ダブルクォートは C 言語式のエスケープ表現で出力される
(たとえば `\ef', `\e"')。他の普通使わない文字には、エスケープした 8 進数が使われる。
それ以外の表示可能な文字は (\fB\-ls\fP や \fB\-fls\fP とっては 8 進数の
041 から 0176 に当たる文字)、手を加えずにそのまま出力される。

.IP "\-printf, \-fprintf"
出力先が端末でない場合は、そのまま出力される。端末の場合は、使用される書式指定子によって、結果は様々である。
書式指定子 %D, %F, %g, %G, %H, %Y, %y が展開される値は、ファイルの所有者の管轄外なので、そのまま出力される。
書式指定子 %a, %b, %c, %d, %i, %k, %m, %M, %n, %s, %t, %u, %U
の値は、ファイル所有者の管轄内ではあるが、それを使って端末に勝手なデータを送ることはできない。
従って、そのまま出力される。書式指定子 %f, %h, %l, %p, %P はクォートされる。
このクォート方法は、GNU \fBls\fP と同じである (訳注: 厳密に言うと、現在のところ
\fBls \-N\fP と同じ。\fBls\fP はバージョンによっては、デフォルトの表示が \fB\-N\fP
ではないことがある)。つまり、\fB\-ls\fP や \fB\-fls\fP
におけるクォート方法とは違うということだ。もし、\fBfind\fP
の出力に使用する形式を自由に決めることができるならば、たいていの場合、
終端文字に改行ではなく、`\e0' を使用した方がよい。
ファイル名には空白や改行が含まれていることがあるからだ。
どの文字にクォートが必要かを判断するには、環境変数 `LC_CTYPE' の設定が使用される。

.IP "\-print, \-fprint"
クォートは \fB\-printf\fP や \fB\-fprintf\fP と同じやり方で行われる。
\fBfind\fP をスクリプト中で使っている場合や、マッチするファイルが我儘なファイル名を持っているかもしれない場合は、\fB\-print\fP ではなく、
\fB\-print0\fP の使用を考えた方がよいだろう。
.P
アクション \fB\-ok\fP と \fB\-okdir\fP は、対象となるファイル名をそのまま手を加えずに出力する。
この動作は、将来のリリースで変わるかもしれない。

.SH 規格への準拠
POSIX 規格にできるだけ準拠した動作を求めるのなら、環境変数 POSIXLY_CORRECT
を設定するとよい。以下のオプションや述語は POSIX 規格
(IEEE Std 1003.1, 2003 Edition) で規定されている。

.IP \fB\-H\fP
このオプションはサポートしている。

.IP \fB\-L\fP
このオプションはサポートしている。

.IP \fB\-name\fP
この述語はサポートしている。しかし、POSIX への準拠度は、システムの
\fBfnmatch\fP(3) ライブラリ関数がどの程度 POSIX に準拠しているかに依存している。
findutils\-4.2.2 以来、シェルのメタ文字 (`*', `?', `[]' など) は、
ファイル名の先頭の `.' 文字にマッチするが、これは IEEE PASC interpretation 126
がそう要求しているからである。この動作は それ以前のバージョンの findutils と異なっている。

.IP \fB\-type\fP
サポートしている。POSIX では `b', `c', `d', `l', `p', `f', `s'
を規定している。GNU find は、そのほか「ドア」を表す `D' もサポートしているが、
使えるのは OS がそうしたファイル・タイプを用意している場合のみである。

.IP \fB\-ok\fP
サポートしている。プロンプトに対する応答は、"yes"、"no"
を表すパターンに照らして解釈されるが、そのパターンは、環境変数
`LC_MESSAGES' を設定することによって選択される。環境変数
`POSIXLY_CORRECT' が設定されている場合は、何が肯定的応答 (yes)
で、何が否定的応答 (no) かを決めているシステムの定義が、このパターンとして使用される。
\fBnl_langinfo\fP(3) に関するシステムの文書、特に YESEXPR と NOEXPR
の部分を参照してほしい。それに対し、`POSIXLY_CORRECT' が設定されていない場合は、
パターンは、システムではなく、\fBfind\fP の持つメッセージ・カタログから取得されるのである。

.IP \fB\-newer\fP
サポートしている。指定されたファイルがシンボリックリンクの場合は、必ずリンク先が参照される
(訳注: 訳者としては、「\fB\-L\fP や \fB\-H\fP オプションが有効な場合は」という条件が必要ではないかと思う。
\fB\-P\fP, \fB\-L\fP, \fB\-H\fP オプションや、検査 \fB\-newer\fP の説明を参照)。
以前のバージョンでは、シンボリックリンクそのものから比較に使う日時を取得していたが、
動作がこのように変更になった。後述の「履歴」セクションも参照してほしい。

.IP \fB\-perm\fP
サポートしている。環境変数 POSIXLY_CORRECT が設定されていない場合は、POSIX
では無効な (たとえば、+a+x といった) モード指定の引き数も、後方互換のために使用できるようになっている
(訳注: \fBfind\fP 4.6.0 では、POSIXLY_CORRECT が設定されていないときでも、+a+x のような
\fB\-perm\fP +\fImode\fP の形式は使えなくなっている)。

.IP その他の述語
\fB\-atime\fP, \fB\-ctime\fP, \fB\-depth\fP, \fB\-group\fP, \fB\-links\fP, \fB\-mtime\fP,
\fB\-nogroup\fP, \fB\-nouser\fP, \fB\-perm\fP, \fB\-print\fP, \fB\-prune\fP, \fB\-size\fP,
\fB\-user\fP \fB\-xdev\fP といった述語は、すべてサポートしている。

.P
POSIX 規格は、カッコ `(', `)'、否定 `!'、それに and と or 演算子
(\fB\-a\fP, \fB\-o\fP) を規定している。
.P
上記以外のすべてのオプション、述語、式などは、POSIX 規格にない拡張である。
とは言え、そうした拡張の多くは、GNU find に特有なものではない。
.P
POSIX 規格によれば、 \fBfind\fP はループを検出することになっている。
.IP
\fBfind\fP ユーティリティは無限ループを検出しなければならない。
無限ループとは、探索中に入ったディレクトリが、すでに訪れたことがあり、しかも直前に処理対象にしたファイルの上位にあるディレクトリであることである。
無限ループを検出した場合、find
は何が起きたかを告げる診断メッセージを標準エラーに表示し、探索位置をディレクトリ階層上の元の位置に戻すか、終了すべきである。
.P
GNU \fBfind\fP はそうした要求に従っている。
ディレクトリがその中に上位ディレクトリへのハードリンクであるエントリを含んでいる場合は、
ディレクトリのハードリンク数が、そのエントリが普通のサブディレクトリならそうなるはずの数よりも、たいてい少なくなるものだ
(訳注: 実際には、Linux を始め、ディレクトリのハードリンクを禁止しているシステムが多い)。その結果、
GNU find が時として、実際には上位ディレクトリへのハードリンクであるサブディレクトリを、最適化の副作用で探索しないことが起こりえる。その場合、
\fBfind\fP は確かにそうしたディレクトリに足を踏み入れないわけだから、「ループ検出」の診断メッセージを出さないでもよいことになっている。
これはかなり紛らわしい動作かもしれないが、\fBfind\fP のこの動作を本気で当てにしている人もいないことだろう。
\fB\-noleaf\fP オプションを指定して、ディレクトリ・ツリー上の葉っぱを簡易判別する最適化を無効にしている場合は
(訳注: \fB\-noleaf\fP 参照)、こうしたディレクトリ・エントリに対する検査も省略されずに行われ、
必要ならば、診断メッセージが表示されることになる。シンボリックリンクを使っていれば、
ファイルシステム上に本物の循環を起こすことはないが、それでも、\fB\-L\fP や \fB\-follow\fP
を使用している場合は、探索中にシンボリックリンクのループに出会えば、診断メッセージが表示される。
ハードリンクを含むループの場合と同様、葉っぱを簡易判別する最適化を使用していると、
\fBfind\fP はたいていの場合、シンボリックリンクに対して \fIstat()\fP や \fIchdir()\fP
を呼び出すまでもないと知っていることになるので、ループの診断は不要になることが多い。
.P
\fB\-d\fP オプションは BSD システム各種との互換性のためにサポートされている。
だが、POSIX に準拠している \fB\-depth\fP オプションの方を使った方がよい。
.P
環境変数 POSIXLY_CORRECT は、検査 \fB\-regex\fP や \fB\-iregex\fP の動作に影響を与えない。
そうした検査は、POSIX 規格で規定されていないからである。
.SH 環境変数

.IP LANG
国際化関係の環境変数のうち、値が設定されていなかったり、null
だったりする変数に対して、LANG の値がデフォルトの値になる。

.IP LC_ALL
この環境変数が空文字列以外の値に設定されていると、その値が国際化関係の他のすべての環境変数の値よりも優先される。

.IP LC_COLLATE
POSIX の規定によれば、この環境変数は検査 \fB\-name\fP で使われるパターンマッチングに影響する。
GNU find は \fBfnmatch\fP(3) ライブラリ関数を使用しているので、LC_COLLATE
への対応はシステムのライブラリ次第である。また、この変数はアクション \fB\-ok\fP
に対する応答の解釈にも影響を及ぼす。 \fB\-ok\fP に対する応答の解釈に使用される実際のパターンは
LC_MESSAGES 変数によって選択されるのだが、そのパターン中に角カッコ式が使われている場合の解釈は、LC_COLLATE
の影響を受けるのである。

.IP LC_CTYPE
この環境変数は、正規表現で使用される文字クラスの処理に影響する。
システムの \fBfnmatch\fP(3) ライブラリ関数が対応している場合は、検査 \fB\-name\fP
で使われる文字クラスの処理にも影響を及ぼす。また、この変数は、アクション \fB\-ok\fP
が出すプロンプトに対してユーザが応答する際、諾否の判断に使用される正規表現に文字クラスが使われていれば、
その解釈にも影響する。さらにまた、環境変数 LC_CTYPEは、ファイル名が表示されるとき、どの文字を表示不可能 (unprintable)
と見なすかにもかかわることになる。「変わり者のファイル名」セクションを参照していただきたい。

.IP LC_MESSAGES
国際化されたメッセージで使用するロケールを決める。環境変数 `POSIXLY_CORRECT'
が設定されている場合でも、やはりこの変数によって、アクション \fB\-ok\fP
が出したプロンプトに対する応答をどう解釈するかが決まってくる。

.IP NLSPATH
国際化メッセージ・カタログを置く場所を決める。

.IP PATH
\fB\-exec\fP, \fB\-execdir\fP, \fB\-ok\fP, \fB\-okdir\fP
によって呼び出される実行ファイルを捜すために検索するディレクトリに影響する。

.IP POSIXLY_CORRECT
\fB\-ls\fP や \fB\-fls\fP が使用するブロックサイズを決める。\fBPOSIXLY_CORRECT\fP
が設定されているときは、1 ブロック 512 バイト、設定されていないときは、1 ブロック
1024 バイトである。
.IP
また、この変数を設定すると、警告メッセージを出さないのがデフォルトになる
(すなわち、 \fB\-nowarn\fP になるわけだ)。なぜならば、POSIX の規定では、\fB\-ok\fP
の出すプロンプトを除いて、標準エラーに出力されるメッセージは、すべて問題が起きたことを知らせるものであり、
そのときの終了ステータスは 0 以外でなければならないからである。
.IP
POSIXLY_CORRECT が設定されていない場合は、+zzz
が許可属性を表すシンボルとしてそれ自体有効な表現であるときを除き、\fB\-perm\fP +zzz
は \fB\-perm\fP /zzz とまったく同じように扱われる (訳注: 現在では、
POSIXLY_CORRECT が設定されていない場合も、\fB\-perm\fP +\fImode\fP
の書式はサポートされていない。検査 \fB\-perm\fP の説明を参照)。POSIXLY_CORRECT
が設定されている場合は、許可属性の前に '+' を取る形式は、エラーとして処理される
(訳注: もちろん、+zzz がそれ自体有効なシンボル表現であるときは除く。たとえば、\fB\-perm +u+x\fP
といったものがそういう表現である。これは、\fB\-perm 0111\fP
という「ぴったり一致する」表現と等価になる)。
.IP
POSIXLY_CORRECT が設定されていると、アクション \fB\-ok\fP
が出すプロンプトに対するユーザの応答を解釈する際に、\fBfind\fP
の持つメッセージ翻訳ではなく、システムのメッセージ・カタログが参照される。

.IP TZ
タイムゾーンに影響する。タイムゾーンは、\fB\-printf\fP や \fB\-fprintf\fP の日時に関係する一部の書式指定子で使用される。
.SH 用例
.nf
\fBfind /tmp \-name core \-type f \-print | xargs /bin/rm \-f\fP

.fi
\fB/tmp\fP ディレクトリ以下に \fBcore\fP という名前のファイルを捜して、それを消去する。
ファイル名 (パスを含む) の中に改行、シングルクォート、ダブルクォート、
空白などを含むものがあると、正しく動作しないので、注意すること。
.P
\fBfind /tmp \-name core \-type f \-print0 | xargs \-0 /bin/rm \-f\fP

.fi
\fB/tmp\fP ディレクトリ以下に \fBcore\fP という名前のファイルを捜して、それを消去する。
ファイル名の処理に当たっては、ファイルやディレクトリの名前にシングルクォート、ダブルクォート、空白、改行などが含まれていても、適切に扱われるようにしている。
検査 \fB\-name\fP を \fB\-type\fP の前に置いているのは、すべてのファイルに対して
\fBstat(2)\fP システムコールを行う無駄を省くためである。

.P
.nf
\fBfind . \-type f \-exec file \(aq{}\(aq \e;\fP

.fi
カレントディレクトリ以下のあらゆるファイルに対して file コマンドを実行する。
波カッコをシングルクォートで囲んでいることに注目していただきたい。
シェルスクリプトのブロック区切り記号として解釈されないようにするためである。
同様に、セミコロンもバックスラッシュを使って保護している。
こちらにもシングルクォートを使用してもよい。

.P
.nf
\fBfind / \e( \-perm \-4000 \-fprintf /root/suid.txt \(aq%#m %u %p\en\(aq \e) , \e\fP
\fB\e( \-size +100M \-fprintf /root/big.txt \(aq%\-10s %p\en\(aq \e)\fP

.fi
全ファイルシステムを一回だけ探索して、setuid ビットの立っているファイルやディレクトリのリストを
\fB/root/suid.txt\fP に、サイズの大きいファイルのリストを \fB/root/big.txt\fP に出力する。

.P
.nf
\fBfind $HOME \-mtime 0\fP

.fi
ここ 24 時間の内に内容が更新されたファイルをホームディレクトリ以下で検索する。
このコマンドがそういう動作になるのは、それぞれのファイルが最後に更新されてから現在までの経過時間が、24 時間で割られて、余りは捨てられるからである。
そこで、ファイルが \fB\-mtime 0\fP にマッチするためには、過去 24 時間未満の期間内に内容が更新されていなければならないことになる。

.P
.nf
\fBfind /sbin /usr/sbin \-executable \e! \-readable \-print\fP

.fi
実行可能でありながら、読み出し不可能なファイルを捜す。

.P
.nf
\fBfind . \-perm 664\fP

.fi
ファイルの所有者とグループは読むことも書くことも可能だが、他のユーザは読み出しのみ可能で書き込みはできないファイルを捜す。
そうした条件を満たすものの、他の許可属性ビットも立っているような
(たとえば、そのファイルを実行できる人がいるような) ファイルは、この式にマッチしない。

.P
.nf
\fBfind . \-perm \-664\fP

.fi
ファイルの所有者とグループは読むことも書くことも可能であり、他のユーザも読むことが可能であるようなファイルを捜す。
それ以外の許可属性ビットについては (たとえば、実行許可ビット)、立っていてもいなくてもかまわない。この条件は、たとえば、 0777
のモードを持つファイルにもマッチすることになる。

.P
.nf
\fBfind . \-perm /222\fP

.fi
書き込める人のいるファイルを捜す (書き込めるのは、ファイルの所有者でも、グループでも、他の一般ユーザでもよい)。

.P
.nf
\fBfind . \-perm /220\fP
\fBfind . \-perm /u+w,g+w\fP
\fBfind . \-perm /u=w,g=w\fP

.fi
上記のコマンドは三つとも同じ動作をする。最初のものは、ファイルの許可属性を
8 進数で表し、後の二つは、シンボルによる表現形式を使っている。
こうしたコマンドはどれも、ファイルの所有者やグループが書き込み可能なファイルを捜す。
所有者とグループの両方が書き込み可能な場合しか、マッチしないわけではない。
どちらか片方だけでも十分である。

.P
.nf
\fBfind . \-perm \-220\fP
\fBfind . \-perm \-g+w,u+w\fP

.fi
この二つのコマンドは同じ動作をする。すなわち、ファイルの所有者とグループの両方が書き込み可能なファイルを捜す。

.P
.nf
\fBfind . \-perm \-444 \-perm /222 \e! \-perm /111\fP
\fBfind . \-perm \-a+r \-perm /a+w \e! \-perm /a+x\fP

.fi
この二つのコマンドは両方とも次のような条件のファイルを捜す。
その条件とは、誰にでも読み出すことが可能で (\fB\-perm \-444\fP や \fB\-perm \-a+r\fP
がそれにに当たる)、書き込み許可ビットが少なくとも一つは立っているが
(\fB\-perm /222\fP や \fB\-perm /a+w\fP)、誰にも実行することはできない (\fB! \-perm /111\fP
や \fB! \-perm /a+x\fP) というものである。

.P
.nf
\fBcd /source\-dir\fP
\fBfind . \-name .snapshot \-prune \-o \e( \e! \-name \(aq*~\(aq \-print0 \e)|\fP
\fBcpio \-pmd0 /dest\-dir\fP

.fi
このコマンドは \fB/source\-dir\fP の中身を \fB/dest\-dir\fP にコピーするが、
その際 \fB.snapshot\fP という名前のファイルやディレクトリ (及び、そのディレクトリ内にあるもの) を除外している。
さらにこのコマンドは、名前の末尾に \fB~\fP が付くファイルやディレクトリも除外するが、
そうしたディレクトリの中身については除外の対象にしない。
\fB\-prune \-o \e( \&...\& \-print0 \e)\fP という構文はかなりよく利用される。
ここで肝腎なのは、\fB\-prune\fP の前にある式がマッチする項目は、\fBfind\fP の探索の対象から
\fB\-prune\fP によって取り除かれる (訳注: pruned、枝刈りされる) ということである。
しかし、アクション \fB\-prune\fP 自体は返り値として真を返すので、直後に続く \fB\-o\fP
によって、探索の対象から取り除かれなかったディレクトリに対してだけ \fB\-o\fP の右辺の評価が行われることになる
(探索の対象から取り除かれたディレクトリの中身は、処理の対象にすらならないのだから、そうしたものはもう関係がない)。
\fB\-o\fP の右辺の式をカッコで囲んでいるのは、見やすくするためにすぎない。
アクション \fB\-print0\fP が行われるのは、 \fB\-prune\fP が適用されなかった項目のみであることを強調しているだけだ。
述語間のデフォルトの結合は and であり、and の結合は \fB\-o\fP よりも強いから、
カッコがあってもデフォルトの動作と同じなのだが、カッコを使うと、何をやっているかがわかりやすくなる。

.P
.nf
\fBfind repo/ \e( \-exec test \-d {}/.svn \e; \-or \e\fP
\fB\-exec test \-d {}/.git \e; \-or \-exec test \-d {}/CVS \e; \e) \e\fP
\fB\-print \-prune\fP
.fi

以下のようなプロジェクトのディレクトリとそれに関連する SCM (ソースコード管理システム)
の管理用ディレクトリがある場合に、プロジェクトのルートを効率的に検索する。

.nf
\fBrepo/project1/CVS\fP
\fBrepo/gnu/project2/.svn\fP
\fBrepo/gnu/project3/.svn\fP
\fBrepo/gnu/project3/src/.svn\fP
\fBrepo/project4/.git\fP

.fi
この例では、\fB\-prune\fP を使うことによって、すでにプロジェクトのルートであることがわかったディレクトリ以下で不必要な探索をしないですませている
(たとえば、project3/src は探索しないが、それは project3/.svn
がすでに見つかっているからだ)。それでいて、同格のディレクトリ (たとえば、
project2 と project3) はきちんと見つかるようにしている。
(訳注: この例の場合、カッコは必要である。and の結合は or よりも強いので。)

.SH 終了ステータス
.PP
\fBfind\fP は、すべてのファイルを問題なく処理できれば、ステータス 0 で終了する。
エラーが起きた場合の終了ステータスは、1 以上である。
ここではあえてごく大雑把な言い方をしているが、返り値が 0 以外だった場合は、\fBfind\fP
が出した結果を正しいと思い込まない方がよいだろう。

エラーが起きた場合、\fBfind\fP は、指定されたすべての動作を完了せず、
その場で終了してしまうことがある。その場合は、たとえば、探索開始点のあるものが調査されなかったり、
\fB\-exec \&...\& {} +\fP や \fB\-execdir \&...\& {} +\fP
で呼び出されることになっているプログラムに実行されないものが生じたりするかもしれない。


.SH 関連項目
\fBlocate\fP(1), \fBlocatedb\fP(5), \fBupdatedb\fP(1), \fBxargs\fP(1), \fBchmod\fP(1),
\fBfnmatch\fP(3), \fBregex\fP(7), \fBstat\fP(2), \fBlstat\fP(2), \fBls\fP(1),
\fBprintf\fP(3), \fBstrftime\fP(3), \fBctime\fP(3)

\fBfind\fP については、充実した関連文書が Texinfo マニュアルの形で保守されている。
\fBinfo\fP と \fBfind\fP プログラムが、御使用のサイトできちんとインストールされているならば、
\fBinfo find\fP とコマンドを打ち込むことで、詳細なマニュアルが読めるはずだ。
(訳注: \fBinfo find\fP だと、説明が途中からになるので、\fBinfo "Finding files"\fP
と打ち込むことをお勧めする。)

.SH 履歴
findutils\-4.2.2 以来、ファイル名のパターンに使われるシェルのメタ文字
(`*', `?', `[]' など) は、先頭の `.' にマッチする。
これは、IEEE POSIX interpretation 126 がそう要求しているからである。
.P
findutils\-4.3.3 以来、\fB\-perm /000\fP
は、どんなファイルにもマッチしないではなく、すべてのファイルにマッチする、になっている。
.P
ナノ秒まで表現するタイムスタンプは findutils\-4.3.3 で実装された。
.P
findutils\-4.3.11 以来、アクション \fB\-delete\fP は、実行に失敗すると、
\fBfind\fP の終了ステータスを 0 以外の値にする。とは言え、\fBfind\fP
がその場で即座に終了してしまうわけではない。以前のバージョンでは、\fB\-delete\fP
が実行に失敗しても、\fBfind\fP の終了ステータスは影響を受けなかった。
.TS
l l l .
Feature	Added in	Also occurs in
\-newerXY	4.3.3	BSD
\-D	4.3.1
\-O	4.3.1
\-readable	4.3.0
\-writable	4.3.0
\-executable	4.3.0
\-regextype	4.2.24
\-exec ... +	4.2.12	POSIX
\-execdir	4.2.12	BSD
\-okdir	4.2.12
\-samefile	4.2.11
\-H	4.2.5	POSIX
\-L	4.2.5	POSIX
\-P	4.2.5	BSD
\-delete	4.2.3
\-quit	4.2.3
\-d	4.2.3	BSD
\-wholename	4.2.0
\-iwholename	4.2.0
\-ignore_readdir_race	4.2.0
\-fls	4.0
\-ilname	3.8
\-iname	3.8
\-ipath	3.8
\-iregex	3.8
.TE
.P
\fB\-perm +MODE\fP という書き方は、findutils\-4.5.12 で廃止された。代わりに、\fB\-perm /MODE\fP を使用すること。
\fB+MODE\fP という記法は、2005 年にリリースされた findutils\-4.2.21 以来非推奨になっていた。
.P
.SH バグにあらず
.nf
\fB$ find . \-name *.c \-print\fP
find: paths must precede expression
Usage: find [\-H] [\-L] [\-P] [\-Olevel] [\-D help|tree|search|stat|rates|opt|exec] [path...] [expression]
.fi
.P
こうしたエラーが起きる原因は、 \fI*.c\fP がシェルによって展開されて、\fBfind\fP
が実際に受け取るコマンドラインが、たとえば次のようなものになってしまうからである。
.nf

\fBfind . \-name bigram.c code.c frcode.c locate.c \-print\fP

.fi
当然ながら、こんなコマンドがうまく動くわけがない。書き方を改めて、パターンを引用符で囲むか、ワイルドカードをエスケープするべきだ。
.nf
\fB$ find . \-name \(aq*.c\(aq \-print\fP
\fB$ find . \-name \e*.c \-print\fP
.fi

.SH バグ
.P
POSIX 規格が \fBfind\fP について規定している動作には、セキュリティ上の問題があるが、
それはその動作に内在する問題なので、修正することができない。一例を挙げると、アクション
\fB\-exec\fP は本質的に安全ではない。だから、\fB\-execdir\fP
の方を使うべきなのだ。より詳しい情報については、\fBFinding Files\fP をご覧いただきたい。
.P
環境変数 \fBLC_COLLATE\fP はアクション \fB\-ok\fP にまったく影響を及ぼさない
(訳注: 環境変数 \fBLC_COLLATE\fP の説明では 「この変数はアクション \fB\-ok\fP
に対する応答の解釈にも影響を及ぼす」と述べている)。
.P
バグ報告の最善の方法は、http://savannah.gnu.org/bugs/?group=findutils
にある書式を使用することである。そうすれば、問題解決の進行状態を追うことができるからだ。
\fBfind\fP(1) や findutils パッケージ全般についてのその他のご意見は、
\fIbug\-findutils\fP メーリングリストにお出しになればよい。
メーリングリストに参加するには、\fIbug\-findutils\-request@gnu.org\fP 宛に
E メールを送っていただきたい。
.SH 翻訳について
この翻訳は findutils-4.6.0 所収の find.1 の翻訳である。
お手元の findutils は、もっと新しいバージョン、たとえば 4.7.0-git
になっているかもしれない。だが、4.7.0 は開発中の版なので、manpage 
も変化し続けており、現時点で最新の 4.7.0 
のマニュアルを翻訳しても、お手元の英語マニュアルとは内容が微妙に違うかもしれないのだ。
バージョンが同じ 4.7.0 なのに、それでは紛らわしい。そこで、あえて現在の安定版、4.6.0 
のマニュアルを底本にした。
.PP
4.6.0 と\fB最近の\fP 4.7.0-git との大きな相違は、\fB\-D\fP 
のデバックオプションに exec と search が増えていることと、検査 
\fB\-type\fP や \fB\-xtype\fP で "-type f,l" 
などと、複数のファイルタイプをコンマで区切って指定できるようになったことくらいである。
.PP
なお、バージョン 4.4.2 までの翻訳では、述語の Test 
(\fB\-mtime\fP, \fB\-name\fP, \fB\-type\fP など) 
を「判別式」と訳してきたが、今回は素直に「検査」と訳すことにした。同じものである。
「条件、条件式、検索式、検索条件、テスト」などの訳語もあったと思う。
これまでの「判別式」という訳語に慣れた方には、ご迷惑だったかもしれない。
お許しいただきたい。(2018/03/03)
